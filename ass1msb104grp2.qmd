---
title: "Assignment 1:"
subtitle:  "Regional GDP Inequality in 4 Selected European Economies"
author: "Kristoffer Tufta and Harald Vika"
date: last-modified
date-format: "dddd D MMM, YYYY"
csl: apa7.csl
citeproc: true
lang: en-GB
format:
  html: default
  typst:
    papersize: a4
  pdf: 
    documentclass: article
    number-sections: true
    keep-tex: true
    papersize: A4
    fig-pos: "H"
abstract: ""
editor: 
  markdown: 
    wrap: sentence
echo: false
bibliography: references.bib
---

```{r}
#| label: setup
library (tidyverse)
library (PxWebApiData)
library(readxl)
library(purrr)
library(dineq)
library(psych)
library(flextable)
# define not in
`%nin%` <- Negate(`%in%`)
```

## Data Acquisition

In this assignment we will use data for four selected countries from Eurostat and process it to analyse the sub-national GDP (gross domestic product) and population data from the years 2000-2023.
Eurostat serves as the statistical office of the European Union, and their work is to collect and provide statistics on EU countries, through reliable, impartial and comparable data.
The countries we have analysed are Germany, Switzerland, Croatia and Ireland.
In these datasets we encountered missing values which we decided to keep.
These NA, or missing data was caused by different reasons for each country.

-   Germany which has the most observations, lacks data for GDP for year 2023 in a lot of its regions. This can be because of late reporting of its data to Eurostat. There are also some missing data on population during 2000-2010 and a few other regions during 2000-2023 which may be caused by the emergence of new regions or changes in districts such that updates are required.
-   Ireland lacks data from the early 2000 to 2011 in population due to changes in NUTS 3 level in their regions. When it comes to the GDP, Ireland only misses data from 2015-2017 in Mid-West and South-West. This was due to confidentiality concerns [@recentt].
-   Croatia only have NA values on population but its spread out on different regions. The same occurs for Germany, here the lack of data can be explained by the changes in regions and districts, which may be the cause of the spread in NA values. It has also been shown that the NUTS2 regions have changed from 2007 to 2021, and the data has been reported using several different NUTS-definitions [@thenuts].
-   Switzerland is a non-EU, but EFTA country, and did not have a data-sharing agreement with Eurostat for NUTS3 GDP from 2000-2007. In 2008 the NUTS classification was updated and it was standardized across all regions [@informat]. Switzerland also lacks the data from 2022-2023 which may be that they are waiting to finalize the data before releasing it.

We will below calculate the GDP per capita and explore regional inequality through a EDA (exploratory data analysis)

### GDP per Region

In @lst-read-in-data, we use the `read_excel` function from the package `readxl` to read the downloaded GDP data from Eurostat into R.
We store it in memory as a tibble called `gdp_wide`.

```{r}
#| lst-label: lst-read-in-data
#| lst-cap: Code for reading data from Excel workbooks into R.
# Har valg display settings hos eurostat slik at
# jeg får med NUTS3 code og ingen flags mellom 
# data kolonnene. Med litt hjelp klarer read_excel()
# å lese inn dataene riktig. Jeg vil foreslå å
# endre navn til gdp_wide
gdp_wide <- read_excel(
  path = "./Data/gdp.xlsx", 
  sheet = "Sheet 1",
  skip = 9,
  na = c(NA, ":"),
  # Har endret navn fra Geo_Labels til NUTS3
  col_names = c("NUTS3", "NUTS3name", as.character(2000:2023)),
  col_type = c(rep("text", 2), rep("numeric", 24))
)
```

```{r}
#| eval: false
#Removing the metadata from the top and bottom by defining the range.
raw_econ <- read_excel(
  path = "./Data/GDP_noFlag.xlsx", 
  sheet = "Sheet 1", 
  range = "A8:Y464", 
  col_types = "text"
  )
```

```{r}
#| label: tbl-nuts3-de
#| tbl-cap: GNP in millon € for 15 German NUTS3 regions in year 2000.
# ikke så lurt å printe hele denne store
# tabellen, men vi kan jo ta litt av den
#Dropping the first row to align time with years
gdp_wide  |> 
  pivot_longer(
    cols = `2000`:`2023`,
    names_to = "year",
    values_to = "gdp"
  ) |> 
  filter(str_sub(NUTS3, 1, 2) == "DE") |> 
  arrange(year, NUTS3) |> 
  rename(`GDP (mill. €)` = gdp) |> 
  head(n = 15) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 20
  ) |> 
  line_spacing(space = 0.3) |> 
  # big.mark er satt til «narrow no-break space»:   
  # Dette er et unicode tegn og kan finnes ved å velge
  # insert > Special Characters > Insert Unicode i Visual
  # mode. Søk etter `U+202f`.
  colformat_double(j = 4, big.mark = " ") |>
  delete_part("footer")
```

```{r}
# Making raw_econ into long format.
# Foreslår navneskifte til gdp
# Foreslår tildvarende skifte for
# variabelnavnet fra "GDP Million EUR"
# til "GDP". HVis vi trenger det mer
# presise navnet f.eks i en tabell eller
# figur så kan vi bare rename() i pipe-en.
gdp <- gdp_wide |> 
  pivot_longer(
    cols = -c(NUTS3, NUTS3name),
    names_to = "Time",
    values_to = "GDP"
    )
```

```{r}
# se def. av nin i setup chunk
gdp |> 
  filter(str_sub(NUTS3, 1, 2) %nin% c("CH", "DE", "HR", "IE")) |> 
  dim()
```

```{r}
# clean up
gdp <- gdp |> 
  filter(str_sub(NUTS3, 1, 2) %in% c("CH", "DE", "HR", "IE"))
```

### Demographic Data

Similarly as before, we do the same for the downloaded demographic dataset from Eurostat, again using the "read_excel"-function.
This time we input the data into a function we have called "raw_demo", before we make it tidy and input that into "tidy_demo".

```{r}
#Removing the metadata from the top.
# Endrer navn
pop_wide <- read_excel(
  path = "./Data/demo_noFlag.xlsx", 
  sheet = "Sheet 1", 
  # Endret på range for å droppe 2 ekstra rekker
  range = "A12:Z487", 
  # prøver samme som for ghdp
  na = c(NA, ":"),
  # Har endret navn fra Geo_Labels til NUTS3
  col_names = c("NUTS3", "NUTS3name", as.character(2000:2023)),
  col_type = c(rep("text", 2), rep("numeric", 24))
  )
```

```{r}
#| eval: false
#Dropping the first row to align time with years
  raw_demo <- raw_demo[-1,]
  names(raw_demo)[1] <- "Geo_Codes"
  names(raw_demo)[2] <- "Geo_Labels"
as_flextable(raw_demo)
```

```{r}
#| label: tbl-nuts3-pop-de
#| tbl-cap: Population for 15 German NUTS3 regions in year 2000.
# ikke så lurt å printe hele denne store
# tabellen, men vi kan jo ta litt av den
#Dropping the first row to align time with years
pop_wide  |> 
  pivot_longer(
    cols = `2000`:`2023`,
    names_to = "year",
    values_to = "pop"
  ) |> 
  filter(str_sub(NUTS3, 1, 2) == "DE") |> 
  arrange(year, NUTS3) |> 
  rename(Population = pop) |> 
  head(n = 15) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 20
  ) |> 
  line_spacing(space = 0.3) |> 
  # Nå heltall så denne må endres til
  # colformat_int(). Merk at vi ikke
  # bruker big.mark på årstall
  colformat_int(j = 4, big.mark = " ") |>
  delete_part("footer")
```





```{r}
# Making raw_demo into long format.
# Nå pop_wide into pop
pop <- pop_wide |> 
  pivot_longer(
    cols = c(-NUTS3, -NUTS3name),
    names_to = "Time",
    # need short names can rename in pipe if needed
    values_to = "pop"
    )
```

```{r}
summary(pop)
```

```{r}
# se def. av nin i setup chunk
pop |> 
  filter(str_sub(NUTS3, 1, 2) %nin% c("CH", "DE", "HR", "IE")) |> 
  dim()
```


## GDP Per capita:

To calculate GDP per capita we have used the NUTS-3 codes from the "Geo_Codes" column as a primary key to join the tidied demographic and economic tables together.
The code chunk below joins the two datasets and adds a new column called "GDP_Capita", calculated by multiplying the "GDP Million EUR"-column by a million and dividing it by the reported population in the same year.
We also add two more columns called "Country" and "NUTS2" by Extracting the first letters (which indicate country and NUTS2-region) from the NUTS3-column.

```{r}
#| label: tbl-tidyjoined
#| tbl-cap: "Joined, tidied datasets"
# Joining the two datasets. Forslår å endre navn til gdp_pop
# Nå får vi betalt for endringene gjort ovenfor
gdp_pop <- left_join(
  x = gdp,
  y = select(pop, -NUTS3name),
  by = join_by(NUTS3, Time)
) |> 
  mutate(
    # since GDP in millons
    GDP_Capita = (1e6 * GDP) / pop
  ) |> 
  mutate(
    NUTS2 = str_sub(NUTS3, start = 1L, end = 4L),
    NUTS1 = str_sub(NUTS3, start = 1L, end = 3L),
    Country = str_sub(NUTS3, start = 1L, end = 2L),
    .before = Time
  ) |> 
  select(Country, everything())
```

```{r}
#| eval: false
#| fig-cap: "Joined, tidied datasets"
# Joining the two datasets
tidyjoined <- left_join(tidy_demo, tidy_econ, by = join_by(Geo_Labels, Time), keep = FALSE)
# Mutating to add column for GDP per capita.
 tidyjoined <- tidyjoined %>%
    mutate(
    `GDP Million EUR` = as.numeric(`GDP Million EUR`),
    Population = as.numeric(Population),
    GDP_Capita = (`GDP Million EUR` * 1000000) / Population
  )
 tidyjoined <- tidyjoined %>%
   mutate(Country = substr(Geo_Codes, 1, 2), .before = 2)
 tidyjoined <- tidyjoined %>%
   mutate( NUTS2 = (str_sub(Geo_Codes, start= 1L, end = 4L)), .before = 2)
as_flextable(tidyjoined)
saveRDS(tidyjoined, "data/tidyjoined.rds")
```


## Descriptive analysis of the "GDP per capita"-table

```{r}
#| echo: false
#| eval: true
# Funksjon for å gi ok output fra psych:describeBy()
# Trenger et describeBy object og hvilket en skal beskrive.
# default er første (1), her er det Sveits ("CH")
# trenger officer pakken
descby <- function(x, y = 1) {
  stopifnot("x must be an describeBy object"= class(x)[2] == "describeBy")
  name = names(x[y])
  obj = x[[y]]
  obj = as_tibble(obj, rownames = "Variables") 
  obj = select(obj, -vars)
  obj = pivot_longer(
    obj,
    cols = n:se,
    names_to = "Statistic",
    values_to ="stat"
  )
  obj = pivot_wider(
    obj,
    names_from = Variables,
    values_from = stat
  )
  obj = rename(obj, `GDP per capita`= GDP_Capita)
  obj = as_flextable(
    obj,
    show_coltype = FALSE
  ) 
  obj = line_spacing(obj, space = 0.3)
  obj = colformat_double(obj, j = 2:4, big.mark = " ", digits = 2)
  obj = colformat_double(obj, i = 1, j = 2:4, big.mark = " ", digits = 0)
  obj = delete_part(obj, "footer")  
  obj = add_header_lines(obj, name)
  obj = hline_top(obj, border = officer::fp_border(width = 0), part = "head")
  
  obj
}
```

```{r}
# warning: false
# Descriptive Analysis grouped by country code
dsby <- gdp_pop |> 
  select(GDP:GDP_Capita) %>%
  describeBy(
  group = gdp_pop$Country
  )
```

### Switzerland

```{r}
#| label: tbl-ch1
#| tbl-cap: Descriptive statistics for Switzerland.
# ingen y, default er 1. Får derfor første land
descby(dsby)
```

```{r}
#| eval: false
#| label: tbl-ch
#| tbl-cap: Descriptive statistics for Switzerland.
library(tidyr)
dsby[[1]] |> 
  as_tibble(rownames = "Variables") |> 
  select(-vars) |> 
  pivot_longer(
    cols = n:se,
    names_to = "Statistic",
    values_to ="stat"
  ) |> 
  pivot_wider(
    names_from = Variables,
    values_from = stat
  ) |> 
  rename(`GDP per capita`= GDP_Capita) |> 
  as_flextable(
    show_coltype = FALSE
  ) |> 
  line_spacing(space = 0.3) |> 
  colformat_double(j = 2:4, big.mark = " ", digits = 2) |>
  colformat_double(i = 1, j = 2:4, big.mark = " ", digits = 0) |>
  delete_part("footer")
```

### Germany

```{r}
#| label: tbl-de
#| tbl-cap: Descriptive statistics for Germany.
descby(dsby, y = 2)
```

### Croatia

```{r}
#| label: tbl-hr
#| tbl-cap: Descriptive statistics for Croatia.
descby(dsby, y = 3)
```

### Ireland

```{r}
#| label: tbl-ie
#| tbl-cap: Descriptive statistics for Irland.
descby(dsby, y = 4)
```

Using the following code, we see that we have a total of 3838 NA-values in our dataset.
Most due to different ways of reporting demographic and economic data, making the datasets hard to pair and leading to even more NA-values in the GDP_Capita-column.

```{r}
#NA for all countries
sum(is.na(gdp_pop))
```

```{r}
# Simple statistics for all countries combined
summary(gdp_pop)
```

```{r}
#| paged.print: false
#| warning: false
all <- gdp_pop |> 
  select(GDP:GDP_Capita) %>%
  describeBy(
    group = gdp_pop$Country %in% c("CH", "DE", "HR", "IE")
  ) |> 
  descby()
# Very ugly hack. If not done it would be TRUE
all$header$content$data[[1]][1] = 'All ("CH", "DE", "HR", "IE")'

all
```


## Using light levels as a predictor of economic development

In this assignment we use reported GDP and demographic data from Eurostat to determine regional inequality in a selection of countries, but what can you do when regional income data isn’t readily available?
The paper “Regional inequality, convergence, and its determinants – A view from outer space” by Christian Lessmann and André Seidel @lessmann2017 aimed to find a new way of finding regional inequalities in areas without economic data – estimating regional income using satellite images of nighttime light intensity.

Their method involved using luminosity data taken from meteorological satellites from the U.S air force, and existing income data to estimate a relationship between the two variables.
They then used this estimate to predict regional income for other regions where economic data was not available, and to calculate inequality indicators such as the Gini coefficient.
The main takeaway from the study would be that yes – it is possible to use light as an indicator of GDP.
Findings also showed that for about 70% of countries, regional gaps got smaller, while other countries saw inequality grow.
They also discovered an “n-shaped” link between development and regional inequality: in early stages of growth inequality is low, for mid-income regions it rises, before it falls again in rich economies.

## Regional GDP inequality - Calculating the Gini coefficient

To calculate the Gini coefficient for our selected countries (weighted for population) we first insert our data including GDP per capita @tbl-tidyjoined into a new function we have called "ginigdp" @tbl-ginigdp.
To be able to calculate the Gini coefficient, we then have to remove NA-values from our dataset.
This can be done by using the "na.omit"-function.
The output is then grouped by year (variable "Time") and region (NUTS2), and sent to a summarise-function which includes our Gini calculation (done by the "gini.wtd"-function).
We have also included a count-column that shows the amount of NUTS3-regions in each of the NUTS2-regions.
This is to provide clarity in case we get "strange" Gini-values like 0, which we would represent ultimate equality.
We will get this in all cases where there is only one NUTS3-region per NUTS2-region.
The code chunk below does all this and prints the first 10 results.

```{r}
# Beregner gini for NUTS2 regioner
ginigdp <- gdp_pop %>%
  na.omit %>%
  group_by(NUTS2, Time)%>%
  summarise(
    Count = n(),
    gini = gini.wtd(GDP_Capita, weights = pop),
    .groups = "drop"
    )
```

```{r}
#| eval: false
#| label: tbl-ginigdp
#| fig-cap: "Regional inequality - full table"
ginigdp <- tidyjoined %>%
  na.omit() %>%
  group_by(NUTS2, Time)%>%
  summarise( Count = n(),
            gini = gini.wtd(GDP_Capita, weights = Population))
as_flextable(ginigdp)
saveRDS(ginigdp, "data/ginigdp.rds")
```




```{r}
#| label: tbl-ginigdp-CH
#| tbl-cap: "Change i gini-coefficients for the NUTS2 regions in Switzerland. The numbers after n3 are the number of NUTS3 regions in the different NUTS2 regions."
ginigdp |> 
  filter(str_sub(NUTS2, 1, 2) == "CH" & Time %in% 2008:2023) |> 
  unite(NUTS2, NUTS2, Count, sep = "\n N3: ") |> 
  pivot_wider(
    names_from = NUTS2,
    values_from = gini
  ) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 25
  ) |> 
  line_spacing(space = 0.3) |> 
  colformat_double(j = 2:8, digits = 4) |> 
  delete_part("footer")
```


```{r}
#| label: tbl-ginigdp-DE2
#| tbl-cap: 'Change i gini-coefficients for the NUTS2 regions in the NUTS1 region "DE2" (Bavaria) in Germany. (N3 number of NUTS3 regions.)'
ginigdp |> 
  filter(str_sub(NUTS2, 1, 3) == "DE2") |> 
  unite(NUTS2, NUTS2, Count, sep = "\n N3: ") |> 
  pivot_wider(
    names_from = NUTS2,
    values_from = gini
  ) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 35
  ) |> 
  line_spacing(space = 0.3) |> 
  colformat_double(j = 2:8, digits = 4) |> 
  autofit() |> 
  theme_booktabs() |> 
  delete_part("footer")
```



```{r}
#| label: tbl-ginigdp-HR
#| tbl-cap: 'Change i gini-coefficients for the NUTS2 regions in Croatia. (N3 number of NUTS3 regions.)'
ginigdp |> 
  filter(str_sub(NUTS2, 1, 2) == "HR") |> 
  unite(NUTS2, NUTS2, Count, sep = "\n N3: ") |> 
  pivot_wider(
    names_from = NUTS2,
    values_from = gini
  ) |> 
  arrange(Time) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 35
  ) |> 
  line_spacing(space = 0.3) |> 
  colformat_double(j = 2:5, digits = 4) |> 
  autofit() |> 
  theme_booktabs() |> 
  delete_part("footer")
```

```{r}
#| paged.print: false
#| label: tbl-ginigdp-IE
#| tbl-cap: 'Change i gini-coefficients for the NUTS2 regions in Ireland. (N3 number of NUTS3 regions.)'
ginigdp |> 
  filter(str_sub(NUTS2, 1, 2) == "IE") |> 
  unite(NUTS2, NUTS2, Count, sep = "\n N3: ") |> 
  pivot_wider(
    names_from = NUTS2,
    values_from = gini
  ) |> 
  arrange(Time) |> 
  as_flextable(
    show_coltype = FALSE,
    max_row = 35
  ) |> 
  line_spacing(space = 0.3) |> 
  colformat_double(j = 2:6, digits = 4) |> 
  autofit() |> 
  theme_booktabs() |> 
  delete_part("footer")
```
If we need to reference the tables we can do it like this @tbl-ginigdp-CH, @tbl-ginigdp-DE2, @tbl-ginigdp-HR and @tbl-ginigdp-IE.

## Visualizing the Gini coefficient

In the sections below, we will use the newly created "ginigdp"-function where all our gini-coefficients have been stored.
To do this, we first filter down to the specific country, before we send the data to ggplot, group it by NUTS2-region and visualize using geom_point and geom_line graphs.

### Switzerland

```{r}
#| label: fig-Switzerland
#| fig-cap: "Regional GDP Inequality in Switzerland by NUTS2-regions."
#Gini Switzerland
#Plot for Switzerland 
ginigdp %>%
  filter(startsWith(NUTS2, "CH")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) +
  geom_line() +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequality in Switzerland", subtitle = "By NUTS2-region")
```

```{r}
#| label: fig-Switzerland-ag
#| fig-cap: "Regional GDP Inequality in Switzerland by NUTS2-regions. Both regions CH04 and CH07 includes only one NUTS3 region and are excluded."
#Gini Switzerland
#Plot for Switzerland 
ginigdp %>%
  filter(startsWith(NUTS2, "CH")) %>%
  filter(NUTS2 %nin% c("CH04", "CH07")) |> 
ggplot(
  mapping = aes(
    x = Time, 
    y = gini, 
    colour = NUTS2, 
    group = NUTS2,
    linetype = NUTS2
    )
  ) + 
  geom_line() +
  labs(x = "Year", y = "Gini-Coefficient")
```



@fig-Switzerland shows low Gini-coefficients for each region, with a tendency to stay below 0.20.
There is seemingly a divide into two groups one of which has a higher gini-coefficient than the other.
While the overall inequality seems to remain low and consistent, we do see a divergence from the rest by CH03 who has seen growing regional inequality the last 10+ years.
This seems to be because CH031 Basel-Stadt has a much higher GDP per capita growth than the surrounding areas.
CH07 stays at 0 for the whole period due to only having one region.

### Ireland

```{r}
#| label: fig-Ireland
#| fig-cap: "Regional GDP Inequality in Ireland"
#Gini Ireland
ginigdp %>%
  filter(startsWith(NUTS2, "IE")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2, )) + 
  geom_point(mapping = aes()) + 
  geom_line() +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequality in Ireland", subtitle = "By NUTS2-region")
```

The irish graph seen in @fig-Ireland shows a bigger spread and more "movement" than the swiss graph.
We only have population data from 2012 onwards, hence our starting point.
As we can see in the graph, IE05 and IE4 start out with similarly low Gini coefficients, both lying around 0.1, whereas IE06, containing the capital Dublin, has a much less even distribution of GDP per capita.
If we take a look at @tbl-tidyjoined, we can see that for the period 2015-2017 no GDP data was reported for the Mid-West and South-West NUTS3-regions, leaving only one NUTS3-region remaining in the IE05 group, giving us a Gini coefficient of 0,0 for those years.
When GDP data returned in 2018, IE053 (South-West) had grown in GDP per capita in a big way, pulling away from the rest of the group and increasing the Gini coefficient.
The graph seems to show a trend towards slowly growing regional inequality of development in Ireland.

### Germany

```{r}
#| label: fig-Germany
#| fig-cap: "Regional GDP Inequality in Germany - Full graph"
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) + 
  geom_line() +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequality in Germany", subtitle = "By NUTS2-region - full graph")
```

```{r}
#| label: fig-Germany-ag1
#| fig-cap: "Regional GDP Inequality in Germany - Full graph. The zones in DE1 are depicted with black solid somewhat thicker lines."
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
  filter(gini > 0) |> 
  mutate(
    year = paste(Time, "01-01", sep = "-"),
    year = ymd(year),
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
ggplot(
      mapping = aes(
      x = year, 
      y = gini
      )
      ) + 
  #geom_point(mapping = aes()) + 
  geom_line(
    # triks for å filtrere data
    data = . %>% filter(!NUTS1 == "DE1"),
    mapping = aes(
      colour = NUTS1,
      linetype = NUTS1,
      group = NUTS2
      )
  ) +
  geom_line(
    # triks for å filtrere data
    data = . %>% filter(NUTS1 == "DE1"),
    mapping = aes(
      group = NUTS2
      ),
    colour = "black", 
    linetype = "solid",
    linewidth = 0.7
    ) +
  #theme(axis.text.x = element_text(angle = 45)) +
  labs(x = "Year", y = "Gini-Coefficient")
```

```{r}
#| label: fig-Germany-ag2
#| fig-cap: "Regional GDP Inequality in Germany - Full graph."
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
  filter(gini > 0) |> 
  mutate(
    year = paste(Time, "01-01", sep = "-"),
    year = ymd(year),
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
ggplot(
      mapping = aes(
      x = year, 
      y = gini
      )
      ) + 
  #geom_point(mapping = aes()) + 
  geom_line(
    mapping = aes(
      colour = NUTS1,
      group = NUTS2
      ),
    linewidth = 0.7
  ) +
 scale_colour_viridis_d() +
  labs(x = "Year", y = "Gini-Coefficient")
```

```{r}
multiN2 <- ginigdp |> 
  filter(
    str_sub(NUTS2, 1, 2) == "DE"
  ) |> 
  mutate(
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
  group_by(NUTS1, Time) |> 
  summarise(
    N2 = n(),
    .groups = "drop"
  ) |> 
  filter(N2 > 1 & Time == 2022) |> 
  select(NUTS1) |> 
  pull()
```

```{r}
oneN2 <- ginigdp |> 
  filter(
    str_sub(NUTS2, 1, 2) == "DE"
  ) |> 
  mutate(
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
  group_by(NUTS1, Time) |> 
  summarise(
    N2 = n(),
    .groups = "drop"
  ) |> 
  filter(N2 == 1 & Time == 2022) |> 
  select(NUTS1) |> 
  pull()
```


```{r}
#| label: fig-Germany-ag3
#| fig-cap: "Regional GDP Inequality in Germany - NUTS1 regions with multiple NUTS2 regions."
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
  filter(gini > 0) |> 
  mutate(
    year = paste(Time, "01-01", sep = "-"),
    year = ymd(year),
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
  filter(NUTS1 %in% multiN2) |> 
  ggplot(
      mapping = aes(
      x = year, 
      y = gini
      )
      ) + 
  geom_line(
    mapping = aes(
      group = NUTS2
      ),
    linewidth = 0.3
  ) +
  facet_wrap(~NUTS1, ncol = 3, scales = "fixed") +
 scale_colour_viridis_d() +
  labs(x = "Year", y = "Gini-Coefficient") +
  theme(legend.position = "none")
```

```{r}
#| label: fig-Germany-ag4
#| fig-cap: "Regional GDP Inequality in Germany - NUTS1 regions with a single NUTS2 region."
#Gini Germany
ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
  filter(gini > 0) |> 
  mutate(
    year = paste(Time, "01-01", sep = "-"),
    year = ymd(year),
    NUTS1 = str_sub(NUTS2, 1, 3)
  ) |> 
  filter(NUTS1 %in% oneN2) |> 
  ggplot(
      mapping = aes(
      x = year, 
      y = gini
      )
      ) + 
  geom_line(
    mapping = aes(
      group = NUTS2
      ),
    linewidth = 0.3
  ) +
  facet_wrap(~NUTS1, ncol = 3, scales = "fixed") +
 scale_colour_viridis_d() +
  labs(x = "Year", y = "Gini-Coefficient") +
  theme(legend.position = "none")
```



Germany has been very consistent at reporting data and we have data for the full period, but as @fig-Germany shows, we have a little bit of an information overload on our hands.
Germany consists of up to 38 NUTS2 regions which is crowding the graph, making it very hard to read.
Our dataset gives a spread from 0 to 0.4 in gini-coefficient.
To combat the information overload we have chosen to extract 10 random regions to get a better picture of Germany's regional inequalities.

```{r}
#| label: fig-DErandom
#| fig-cap: "Regional GDP Inequality in Germany - Random selection"
# Picking out 10 different regions for Germany
# Set.seed to not get random every time one runs the codes
set.seed(123) 

ginigdp %>%
  filter(startsWith(NUTS2, "DE")) %>%
  group_by(NUTS2) %>%
  summarise() %>%
  sample_n(10) %>%
  pull(NUTS2) -> sampled_regions

ginigdp %>%
  filter(NUTS2 %in% sampled_regions) %>%
  ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) +
  geom_point() +
  geom_line() +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequality in Germany", subtitle = "By NUTS2-region - randomly selected.")
 
```

@fig-DErandom takes 10 randomly selected NUTS2 regions and shows the same spread as the one with all regions.
The graph @fig-Germany containing all regions from Germany showed one region with a Gini of 0,4 while most other regions lie between 0,1 and 0,2.
The pattern seems to be the Gini coefficient remains stable over time, but we do have two significant "jumps".
DEB3 shows a significant jump from 0,24 in 2020 to 0,32 in 2021.
This seems to be because DEB35 Mainz doubles in reported GDP, with their population remaining stable leading to a boost in productivity.
The other regions in the group do not see a similar jump, hence inequality grows.
The other jump can be seen in DE80, where we have a jump from 0,017 (extremely low) in 2010 to 0,083 in 2011.
If we refer to the tidyjoined-table @tbl-tidyjoined , we see that population data was only reported for two of the NUTS3-regions in DE80 until 2011, giving us artificially low values for the preceeding period.
The Gini coefficient for DE80 is therefore not comparable between the periods before 2010 and after 2011.
DE60 only contains one NUTS3-region (Hamburg) and is therefore stable at 0.

### Croatia

```{r}
#| label: fig-Croatia
#| fig-cap: "Regional GDP Inequality in Croatia"
#Gini Croatia
ginigdp %>%
  filter(startsWith(NUTS2, "HR")) %>%
ggplot(mapping = aes(x = Time, y = gini, colour = NUTS2, group = NUTS2)) + 
  geom_point(mapping = aes()) + 
  geom_line() +
  theme(axis.text.x = element_text(angle = 45)) +
  labs(x = "Year", y = "Gini-Coefficient", title = "Regional GDP Inequality in Croatia", subtitle = "By NUTS2-region.")
```

The graph of Croatia @fig-Croatia shows us a bit of a different picture from the other countries.
Demographic data seems to be missing in the "ginigdp"-table for all regions but HR03 before 2013, hence the early start for HR03.
Croatia has had its NUTS regions change several times between 2000 to 2023, and the data available from Eurostat contains both the old and new definitions, making it hard to pair the two datasets.
For instance, the capital Zagreb appears as both HR041 and HR050 using different NUTS-definitions.
Because we joined the two Eurostat-datasets by NUTS3-code, we end up getting a graph that looks incomplete, but this appears to be the best way to pair the available datasets with eachother while still limiting room for error.

If we take a look at the calculated Gini coefficients in @tbl-ginigdp , we see that we get very low values for all available croatian regions.
This could usually mean that we have very few NUTS3-regions per group, but if we take a look at the data, we see that this is not the case.
HR06 for instance, has 5 NUTS3-regions inside of it, all with similar GDP per capita.
The fact that all of Croatia's regions have such a low Gini coefficient could indicate that economic development is evenly spread inside the NUTS2-regions.
HR05 only contains the capital Zagreb, and is therefore shown as 0.

## Implications of our findings

In this assignment we have calculated Gini coefficients inside each available NUTS2-region using Eurostat data for Ireland, Germany, Croatia and Switzerland.
The calculated variations in the Gini coefficient tell us something about the variations of gdp per capita inside each NUTS2-region.
A high Gini could indicate that we have a case of a highly productive city-region inside a greater region containing a lot of less productive land.

Overall, the the calculated Gini coefficients seem to be stable over time, except for a few outliers as commented on previously.
This could mean that economic development in our selected countries is mostly stable "across the board", and not especially concentrated in a handful of highly productive cities inside larger regions.

Our findings do however not entirely dismiss the idea that growth and economic development is mostly centered around cities.
If we take a look at the data for Croatia in @tbl-tidyjoined, we can see that Zagreb has been designated as its' own region, with a GDP per capita much higher than the other regions in Croatia.
Had Zagreb instead been a part of any of the other regions, the calculated Gini coefficient would have been much higher than what @fig-Croatia showed.
The same is the case for Berlin, Hamburg and many other highly productive cities, but because they are designated to their own NUTS2-regions, they end up as "blind spots" for this specific assignment and end up with a Gini of 0 (due to only consisting of one NUTS3-region).
To further examine this theory, it would be interesting to look at the calculated Gini coefficients based on variations of GDP per capita per NUTS2 region, which would show variations in GDP per capita inside the whole country, which might be able to pick up these disparities.

## AI Disclaimer

In this assignments we have used AI to confirm through controlling questions and constructive judging the text and the codes used, to provide a constructive feedback.
The AI was used as a sparring partner to help with the wording of the writing and testing of the codes to provide an explanation of how each function in the code works.
The software of AI we used was ChatGPT 3.5, which is the free version available for all users.
It was only used to function test our codes and recommend correct grammar and code syntax.

```{r}
sessionInfo()
citation()
```
